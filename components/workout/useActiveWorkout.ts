import {
  useEffect,
  useRef,
  useCallback,
  useState,
  Dispatch,
  MutableRefObject,
  useMemo,
} from 'react';
import { useImmerReducer } from 'use-immer';
import { Exercise, AppSettings, PersonalItem, WorkoutSet, WorkoutSession } from '../../types';
import { logEvent } from '../../services/correlationsService';
import { saveWorkoutSession, getWorkoutSessions } from '../../services/dataService';
import { getThemeVariables } from './themes';
import {
  PersonalRecord,
  calculatePRsFromHistory,
  isNewPR as checkIsNewPR,
} from '../../services/prService';
import useWorkoutPersistence from '../../hooks/useWorkoutPersistence';
import useWakeLock from '../../hooks/useWakeLock';

// --- Constants & Enums ---

const STORAGE_KEY = 'active_workout_v2_flat';

const HAPTIC_PATTERNS = {
  REST_END: [200, 100, 200],
  SET_COMPLETE: [50, 50, 50],
} as const;

// --- Helper Functions (Pure Logic) ---

const createNextSet = (currentSet: WorkoutSet): WorkoutSet & { isAutoGenerated?: boolean } => ({
  reps: currentSet.reps,
  weight: currentSet.weight,
  notes: currentSet.notes,
  rpe: currentSet.rpe,
  restTime: currentSet.restTime,
  isAutoGenerated: true,
});

const calculateElapsedTime = (startTime: number, totalPaused: number): number => {
  return (Date.now() - startTime - totalPaused) / 1000;
};

const triggerHaptic = (pattern: readonly number[]) => {
  if (typeof navigator !== 'undefined' && navigator.vibrate) {
    navigator.vibrate([...pattern]);
  }
};

const loadAppSettings = (): AppSettings => {
  try {
    const stored = localStorage.getItem('appSettings');
    if (!stored) return {} as AppSettings;

    const parsed = JSON.parse(stored);
    if (parsed && typeof parsed === 'object') {
      return parsed as AppSettings;
    }

    return {} as AppSettings;
  } catch (err) {
    console.error('Failed to parse app settings:', err);
    return {} as AppSettings;
  }
};

// --- Types ---

export type ModalType = 'goal' | 'warmup' | 'cooldown' | 'water' | 'tutorial';

export type WorkoutState = {
  // Data
  exercises: Exercise[];
  currentExerciseIndex: number;

  // Time Tracking (Fixed & Robust)
  startTimestamp: number;
  totalPausedTime: number;
  lastPauseTimestamp: number | null;
  workoutTimerDisplay: number; // For UI compatibility (previously workoutTimer)

  // Legacy Timer Field (mapped to display for compatibility)
  workoutTimer: number;

  isPaused: boolean;
  restTimer: { active: boolean; endTime: number | null; totalTime: number; timeLeft: number }; // timeLeft kept for compatibility

  // --- UI State (Flattened back to root for compatibility) ---
  showSettings: boolean;
  showExerciseSelector: boolean;
  showQuickForm: boolean;
  isDrawerOpen: boolean;
  numpad: { isOpen: boolean; target: 'weight' | 'reps' | null; value: string };

  // Modals (Flattened if possible, but kept managed)
  showGoalSelector: boolean;
  showWarmup: boolean;
  showCooldown: boolean;
  showWaterReminder: boolean;
  showTutorial: boolean;

  tutorialExercise: string | null;
  showConfetti: boolean;
  showPRCelebration: PersonalRecord | null;

  appSettings: AppSettings;

  // Ghost Values
  previousExerciseData: WorkoutSet[] | null;

  // Side-effect flags
  pendingHaptic: 'REST_END' | 'SET_COMPLETE' | null;
};

export type WorkoutAction =
  | { type: 'SYNC_TIMER' }
  | { type: 'SET_EXERCISES'; payload: Exercise[] }
  | { type: 'UPDATE_SET'; payload: { field: 'weight' | 'reps'; value: number } }
  | { type: 'COMPLETE_SET' }
  | { type: 'UNDO_LAST_SET' }
  | { type: 'ADD_EXERCISE'; payload: Exercise }
  | { type: 'REMOVE_EXERCISE'; payload: number }
  | { type: 'REORDER_EXERCISES'; payload: Exercise[] }
  | { type: 'CHANGE_EXERCISE'; payload: number }
  | { type: 'RENAME_EXERCISE'; payload: { index: number; name: string } }
  | {
    type: 'UPDATE_EXERCISE_META';
    payload: {
      index: number;
      muscleGroup?: string;
      tempo?: string;
      targetRestTime?: number;
      tutorialText?: string;
    };
  }
  | { type: 'TOGGLE_PAUSE' }
  | { type: 'SKIP_REST' }
  | { type: 'ADD_REST_TIME'; payload: number }
  | { type: 'SET_REST_TIME'; payload: number }
  | { type: 'OPEN_NUMPAD'; payload: 'weight' | 'reps' }
  | { type: 'CLOSE_NUMPAD' }
  | { type: 'NUMPAD_INPUT'; payload: string }
  | { type: 'NUMPAD_DELETE' }
  | { type: 'NUMPAD_SUBMIT' }
  | { type: 'SET_MODAL_STATE'; payload: { modal: ModalType; isOpen: boolean } }
  | { type: 'UPDATE_SETTINGS'; payload: Partial<AppSettings['workoutSettings']> }
  | { type: 'SHOW_TUTORIAL'; payload: string }
  | { type: 'SHOW_PR_CELEBRATION'; payload: PersonalRecord }
  | { type: 'HIDE_PR_CELEBRATION' }
  | { type: 'HIDE_CONFETTI' }
  | { type: 'CLEAR_PENDING_HAPTIC' }
  | { type: 'SET_PREVIOUS_DATA'; payload: WorkoutSet[] | null }
  | { type: 'TOGGLE_DRAWER'; payload: boolean }
  | { type: 'TOGGLE_SETTINGS'; payload: boolean }
  | { type: 'OPEN_SELECTOR' }
  | { type: 'CLOSE_SELECTOR' }
  | { type: 'OPEN_QUICK_FORM' }
  | { type: 'CLOSE_QUICK_FORM' }
  // Phase 3: New utility actions
  | { type: 'UPDATE_SET_NOTES'; payload: string }
  | { type: 'UPDATE_SET_RPE'; payload: number }
  | { type: 'COPY_PREVIOUS_SET' }
  | { type: 'DUPLICATE_SET' };


const workoutReducer = (draft: WorkoutState, action: WorkoutAction) => {
  switch (action.type) {
    case 'SYNC_TIMER': {
      // Ensure restTimer object exists even for legacy or malformed state
      if (!draft.restTimer) {
        draft.restTimer = { active: false, endTime: null, totalTime: 0, timeLeft: 0 };
      }

      if (!draft.isPaused) {
        const elapsed = calculateElapsedTime(draft.startTimestamp, draft.totalPausedTime);
        draft.workoutTimerDisplay = elapsed;
        draft.workoutTimer = elapsed; // Sync legacy field
      }
      // Sync Rest Timer
      if (draft.restTimer && draft.restTimer.active && draft.restTimer.endTime) {
        const left = (draft.restTimer.endTime - Date.now()) / 1000;
        draft.restTimer.timeLeft = Math.max(0, left);

        if (left <= 0) {
          draft.restTimer.active = false;
          draft.restTimer.endTime = null;
          if (draft.appSettings?.workoutSettings?.hapticsEnabled) {
            draft.pendingHaptic = 'REST_END';
          }
        }
      }
      break;
    }
    case 'TOGGLE_PAUSE':
      draft.isPaused = !draft.isPaused;
      if (draft.isPaused) {
        draft.lastPauseTimestamp = Date.now();
      } else {
        if (draft.lastPauseTimestamp) {
          draft.totalPausedTime += Date.now() - draft.lastPauseTimestamp;
        }
        draft.lastPauseTimestamp = null;
      }
      break;

    case 'SET_EXERCISES':
      // Filter out any exercises without valid names
      draft.exercises = action.payload.filter(ex => ex.name && ex.name.trim());
      break;

    case 'UPDATE_SET': {
      const exercise = draft.exercises[draft.currentExerciseIndex];
      if (!exercise) break;

      let activeSetIndex = exercise.sets.findIndex(s => !s.completedAt);
      if (activeSetIndex === -1) activeSetIndex = exercise.sets.length;
      if (!exercise.sets[activeSetIndex]) exercise.sets[activeSetIndex] = { reps: 0, weight: 0 };

      // Clear auto-generated flag when user modifies
      const activeSet = exercise.sets[activeSetIndex];
      if ('isAutoGenerated' in activeSet) {
        delete activeSet.isAutoGenerated;
      }

      exercise.sets[activeSetIndex][action.payload.field] = action.payload.value;
      break;
    }

    case 'COMPLETE_SET': {
      const exercise = draft.exercises[draft.currentExerciseIndex];
      if (!exercise) break;

      let activeSetIndex = exercise.sets.findIndex(s => !s.completedAt);
      if (activeSetIndex === -1) activeSetIndex = exercise.sets.length;
      if (!exercise.sets[activeSetIndex]) exercise.sets[activeSetIndex] = { reps: 0, weight: 0 };

      const currentSet = exercise.sets[activeSetIndex];
      currentSet.completedAt = new Date().toISOString();

      if ('isAutoGenerated' in currentSet) {
        delete currentSet.isAutoGenerated;
      }

      if (activeSetIndex === exercise.sets.length - 1) {
        exercise.sets.push(createNextSet(currentSet));
      }

      const restTime =
        exercise.targetRestTime || draft.appSettings.workoutSettings?.defaultRestTime || 60;
      if (draft.appSettings.workoutSettings?.hapticsEnabled) {
        draft.pendingHaptic = 'SET_COMPLETE';
      }

      draft.restTimer = {
        active: true,
        endTime: Date.now() + restTime * 1000,
        totalTime: restTime,
        timeLeft: restTime,
      };

      const intensity = draft.appSettings.animationIntensity;
      if (intensity === 'default' || intensity === 'full') {
        draft.showConfetti = true;
      }
      break;
    }

    case 'UNDO_LAST_SET': {
      const exercise = draft.exercises[draft.currentExerciseIndex];
      if (!exercise) break;

      let lastCompletedIndex = -1;
      for (let i = exercise.sets.length - 1; i >= 0; i--) {
        if (exercise.sets[i].completedAt) {
          lastCompletedIndex = i;
          break;
        }
      }

      if (lastCompletedIndex !== -1) {
        delete exercise.sets[lastCompletedIndex].completedAt;

        const nextIndex = lastCompletedIndex + 1;
        const nextSet = exercise.sets[nextIndex];

        if (nextSet && 'isAutoGenerated' in nextSet && nextSet.isAutoGenerated) {
          exercise.sets.splice(nextIndex, 1);
        }
      }
      break;
    }

    case 'ADD_EXERCISE': {
      // Validate: exercise must have a non-empty name
      const exerciseName = action.payload?.name?.trim();
      if (!exerciseName) {
        console.warn('Blocked attempt to add exercise without name');
        break;
      }
      // Ensure the exercise has a clean trimmed name
      draft.exercises.push({
        ...action.payload,
        name: exerciseName,
      });
      break;
    }
    case 'REMOVE_EXERCISE':
      draft.exercises.splice(action.payload, 1);
      if (draft.currentExerciseIndex >= draft.exercises.length) {
        draft.currentExerciseIndex = Math.max(0, draft.exercises.length - 1);
      }
      break;
    case 'REORDER_EXERCISES':
      // Filter out any exercises without valid names
      draft.exercises = action.payload.filter(ex => ex.name && ex.name.trim());
      break;
    case 'CHANGE_EXERCISE':
      draft.currentExerciseIndex = action.payload;
      break;

    case 'SKIP_REST':
      draft.restTimer.active = false;
      draft.restTimer.endTime = null;
      break;
    case 'ADD_REST_TIME':
      if (draft.restTimer.endTime) {
        draft.restTimer.endTime += action.payload * 1000;
      }
      break;

    // --- UI Actions (Restored to Flat Structure) ---
    case 'OPEN_NUMPAD':
      draft.numpad = { isOpen: true, target: action.payload, value: '' };
      break;
    case 'CLOSE_NUMPAD':
      draft.numpad.isOpen = false;
      break;
    case 'NUMPAD_INPUT':
      draft.numpad.value += action.payload;
      break;
    case 'NUMPAD_DELETE':
      draft.numpad.value = draft.numpad.value.slice(0, -1);
      break;
    case 'NUMPAD_SUBMIT': {
      if (draft.numpad.target) {
        let val = parseFloat(draft.numpad.value);
        if (!isNaN(val)) {
          if (draft.numpad.target === 'reps') val = Math.max(0, Math.round(val || 0));

          const exercise = draft.exercises[draft.currentExerciseIndex];
          if (exercise) {
            let activeSetIndex = exercise.sets.findIndex(s => !s.completedAt);
            if (activeSetIndex === -1) activeSetIndex = exercise.sets.length;
            if (!exercise.sets[activeSetIndex])
              exercise.sets[activeSetIndex] = { reps: 0, weight: 0 };
            exercise.sets[activeSetIndex][draft.numpad.target] = val;

            const activeSet = exercise.sets[activeSetIndex];
            if ('isAutoGenerated' in activeSet) {
              delete activeSet.isAutoGenerated;
            }
          }
        }
      }
      draft.numpad.isOpen = false;
      break;
    }

    case 'SET_MODAL_STATE':
      if (action.payload.modal === 'goal') draft.showGoalSelector = action.payload.isOpen;
      if (action.payload.modal === 'warmup') draft.showWarmup = action.payload.isOpen;
      if (action.payload.modal === 'cooldown') draft.showCooldown = action.payload.isOpen;
      if (action.payload.modal === 'water') draft.showWaterReminder = action.payload.isOpen;
      if (action.payload.modal === 'tutorial') draft.showTutorial = action.payload.isOpen;
      break;
    case 'SHOW_TUTORIAL':
      draft.tutorialExercise = action.payload;
      draft.showTutorial = true;
      break;
    case 'SHOW_PR_CELEBRATION':
      draft.showPRCelebration = action.payload;
      break;
    case 'HIDE_PR_CELEBRATION':
      draft.showPRCelebration = null;
      break;
    case 'HIDE_CONFETTI':
      draft.showConfetti = false;
      break;
    case 'TOGGLE_DRAWER':
      draft.isDrawerOpen = action.payload;
      break;
    case 'TOGGLE_SETTINGS':
      draft.showSettings = action.payload;
      break;
    case 'OPEN_SELECTOR':
      draft.showExerciseSelector = true;
      break;
    case 'CLOSE_SELECTOR':
      draft.showExerciseSelector = false;
      break;
    case 'OPEN_QUICK_FORM':
      draft.showQuickForm = true;
      break;
    case 'CLOSE_QUICK_FORM':
      draft.showQuickForm = false;
      break;

    case 'UPDATE_SETTINGS':
      // Ensure appSettings & workoutSettings objects exist even for legacy persisted state
      if (!draft.appSettings) {
        draft.appSettings = {} as AppSettings;
      }
      draft.appSettings.workoutSettings = {
        ...(draft.appSettings.workoutSettings || {}),
        ...action.payload,
      };
      break;
    case 'CLEAR_PENDING_HAPTIC':
      draft.pendingHaptic = null;
      break;
    case 'SET_PREVIOUS_DATA':
      draft.previousExerciseData = action.payload;
      break;

    // Phase 3: Set rest time directly
    case 'SET_REST_TIME': {
      const restTime = action.payload;
      draft.restTimer = {
        active: true,
        endTime: Date.now() + restTime * 1000,
        totalTime: restTime,
        timeLeft: restTime,
      };
      break;
    }

    // Phase 3: Update notes for current set
    case 'UPDATE_SET_NOTES': {
      const exercise = draft.exercises[draft.currentExerciseIndex];
      if (!exercise) break;

      let activeSetIndex = exercise.sets.findIndex(s => !s.completedAt);
      if (activeSetIndex === -1) activeSetIndex = exercise.sets.length - 1;
      if (activeSetIndex < 0) break;

      const set = exercise.sets[activeSetIndex];
      if (set) {
        set.notes = action.payload;
      }
      break;
    }

    // Phase 3: Update RPE for current set
    case 'UPDATE_SET_RPE': {
      const exercise = draft.exercises[draft.currentExerciseIndex];
      if (!exercise) break;

      let activeSetIndex = exercise.sets.findIndex(s => !s.completedAt);
      if (activeSetIndex === -1) activeSetIndex = exercise.sets.length - 1;
      if (activeSetIndex < 0) break;

      const set = exercise.sets[activeSetIndex];
      if (set) {
        set.rpe = action.payload;
      }
      break;
    }

    // Phase 3: Copy values from previous set to current
    case 'COPY_PREVIOUS_SET': {
      const exercise = draft.exercises[draft.currentExerciseIndex];
      if (!exercise) break;

      let activeSetIndex = exercise.sets.findIndex(s => !s.completedAt);
      if (activeSetIndex === -1) activeSetIndex = exercise.sets.length;
      if (activeSetIndex <= 0) break; // No previous set to copy from

      const previousSet = exercise.sets[activeSetIndex - 1];
      if (!previousSet) break;

      if (!exercise.sets[activeSetIndex]) {
        exercise.sets[activeSetIndex] = { reps: 0, weight: 0 };
      }

      const targetSet = exercise.sets[activeSetIndex];
      if (targetSet) {
        targetSet.weight = previousSet.weight || 0;
        targetSet.reps = previousSet.reps || 0;
      }
      break;
    }


    // Phase 3: Duplicate the current active set
    case 'DUPLICATE_SET': {
      const exercise = draft.exercises[draft.currentExerciseIndex];
      if (!exercise) break;

      let activeSetIndex = exercise.sets.findIndex(s => !s.completedAt);
      if (activeSetIndex === -1) activeSetIndex = exercise.sets.length - 1;
      if (activeSetIndex < 0) break;

      const currentSet = exercise.sets[activeSetIndex];
      if (!currentSet) break;

      // Insert a new set with same values after current position
      const newSet: WorkoutSet = {
        weight: currentSet.weight || 0,
        reps: currentSet.reps || 0,
        notes: currentSet.notes,
        rpe: currentSet.rpe,
        restTime: currentSet.restTime,
      };

      exercise.sets.splice(activeSetIndex + 1, 0, newSet);
      break;
    }
  }
};

const createInitialState = (
  item: PersonalItem,
  loadState: () => WorkoutState | null
): WorkoutState => {
  const now = Date.now();
  const initialDuration = item.workoutDuration || 0;
  const defaultAppSettings = loadAppSettings();

  const defaultState: WorkoutState = {
    exercises: item.exercises || [],
    currentExerciseIndex: 0,

    startTimestamp: now - initialDuration * 1000,
    totalPausedTime: 0,
    lastPauseTimestamp: null,
    workoutTimerDisplay: initialDuration,
    workoutTimer: initialDuration,

    isPaused: false,
    restTimer: { active: false, endTime: null, totalTime: 0, timeLeft: 0 },

    showSettings: false,
    showExerciseSelector: false,
    showQuickForm: false,
    isDrawerOpen: false,
    numpad: { isOpen: false, target: null, value: '' },

    showGoalSelector: false,
    showWarmup: false,
    showCooldown: false,
    showWaterReminder: false,
    showTutorial: false,

    tutorialExercise: null,
    showConfetti: false,
    showPRCelebration: null,

    appSettings: defaultAppSettings,
    previousExerciseData: null,
    pendingHaptic: null,
  };

  try {
    const savedState = loadState();
    if (savedState) {
      // Restoring saved workout state

      // Robust Merge: Ensure all critical objects exist even if savedState is partial/old
      return {
        ...defaultState,
        ...savedState,

        // Merge nested objects to prevent undefined properties
        restTimer: { ...defaultState.restTimer, ...(savedState.restTimer || {}) },
        numpad: { ...defaultState.numpad, ...(savedState.numpad || {}) },
        appSettings: { ...defaultState.appSettings, ...(savedState.appSettings || {}) },

        // Ensure exercises is an array
        exercises: Array.isArray(savedState.exercises)
          ? savedState.exercises
          : defaultState.exercises,

        // Force safe values for resumption
        isPaused: true,
        lastPauseTimestamp: Date.now(),
        pendingHaptic: null,
      };
    }
  } catch (err) {
    console.error('Failed to load or migrate workout state:', err);
  }

  // Creating fresh initial state for workout
  return defaultState;
};

const useWorkoutPersonalRecords = (state: WorkoutState, dispatch: Dispatch<WorkoutAction>) => {
  const [prMap, setPRMap] = useState<Map<string, PersonalRecord>>(() => new Map());

  // Load PRs from history once on mount
  useEffect(() => {
    const loadPRs = async () => {
      try {
        const sessions = await getWorkoutSessions();
        setPRMap(calculatePRsFromHistory(sessions));
      } catch (err) {
        console.error('Failed to load PRs:', err);
      }
    };
    loadPRs();
  }, []);

  const lastPRCheckRef = useRef<{
    exerciseIdx: number;
    setCount: number;
    lastSetKey: string | null;
  }>({
    exerciseIdx: -1,
    setCount: 0,
    lastSetKey: null,
  });

  // Detect new PRs whenever sets change for the current exercise
  useEffect(() => {
    try {
      const exercises = Array.isArray(state?.exercises) ? state.exercises : [];
      const currentIdx =
        typeof state.currentExerciseIndex === 'number' ? state.currentExerciseIndex : 0;

      const currentExercise =
        currentIdx >= 0 && currentIdx < exercises.length ? exercises[currentIdx] : undefined;
      if (!currentExercise || !Array.isArray(currentExercise.sets)) return;

      const completedSets = currentExercise.sets.filter(s => s.completedAt);
      const completedCount = completedSets.length;
      if (completedCount === 0) return;

      const lastSet = completedSets[completedCount - 1];
      if (!lastSet) return;

      const lastSetKey = `${lastSet.weight ?? 0}-${lastSet.reps ?? 0}-${lastSet.completedAt ?? ''}`;

      const alreadyChecked =
        lastPRCheckRef.current.exerciseIdx === currentIdx &&
        lastPRCheckRef.current.setCount === completedCount &&
        lastPRCheckRef.current.lastSetKey === lastSetKey;

      if (alreadyChecked) return;

      lastPRCheckRef.current = {
        exerciseIdx: currentIdx,
        setCount: completedCount,
        lastSetKey,
      };

      const existingPR = prMap.get(currentExercise.name);

      if (checkIsNewPR(lastSet, existingPR)) {
        const newPR: PersonalRecord = {
          exerciseName: currentExercise.name,
          maxWeight: lastSet.weight || 0,
          maxReps: lastSet.reps || 0,
          maxWeightReps: lastSet.reps || 0,
          oneRepMax:
            lastSet.weight && lastSet.reps
              ? Math.round(lastSet.weight * (1 + lastSet.reps / 30))
              : 0,
          volumePR: (lastSet.weight || 0) * (lastSet.reps || 0),
          date: lastSet.completedAt || new Date().toISOString(),
          setData: lastSet,
        };

        setPRMap(prev => {
          const next = new Map(prev);
          next.set(currentExercise.name, newPR);
          return next;
        });

        if (state.appSettings?.animationIntensity !== 'off') {
          dispatch({ type: 'SHOW_PR_CELEBRATION', payload: newPR });
        }
      }
    } catch (err) {
      console.error('Failed to evaluate PRs in useWorkoutPersonalRecords', err);
    }
  }, [
    state.currentExerciseIndex,
    state.exercises,
    prMap,
    state.appSettings?.animationIntensity,
    dispatch,
  ]);

  // Auto-hide PR celebration after a few seconds
  useEffect(() => {
    if (!state.showPRCelebration) return;

    const timer = setTimeout(() => dispatch({ type: 'HIDE_PR_CELEBRATION' }), 5000);
    return () => clearTimeout(timer);
  }, [state.showPRCelebration, dispatch]);

  const getPRForExercise = useCallback((exerciseName: string) => prMap.get(exerciseName), [prMap]);

  return { prMap, getPRForExercise };
};

const usePreviousExerciseData = (
  exerciseName: string | undefined,
  dispatch: Dispatch<WorkoutAction>
) => {
  useEffect(() => {
    let isCancelled = false;

    const fetchPreviousData = async () => {
      if (!exerciseName) {
        if (!isCancelled) dispatch({ type: 'SET_PREVIOUS_DATA', payload: null });
        return;
      }

      try {
        const sessions = await getWorkoutSessions();

        if (isCancelled) return;

        sessions.sort((a, b) => {
          const tb = new Date((b.endTime ?? b.startTime) || 0).getTime();
          const ta = new Date((a.endTime ?? a.startTime) || 0).getTime();
          return tb - ta;
        });

        const lastSession = sessions.find(s => s.exercises.some(e => e.name === exerciseName));
        if (lastSession) {
          const exData = lastSession.exercises.find(e => e.name === exerciseName);
          if (exData && !isCancelled) {
            dispatch({ type: 'SET_PREVIOUS_DATA', payload: exData.sets });
            return;
          }
        }

        if (!isCancelled) dispatch({ type: 'SET_PREVIOUS_DATA', payload: null });
      } catch (err) {
        console.error('Failed to fetch previous workout data:', err);
        if (!isCancelled) dispatch({ type: 'SET_PREVIOUS_DATA', payload: null });
      }
    };

    fetchPreviousData();

    return () => {
      isCancelled = true;
    };
  }, [exerciseName, dispatch]);
};

const useWorkoutThemeAndSettings = (appSettings: AppSettings | undefined | null) => {
  // Fallback defensively if persisted state is missing appSettings
  const safeSettings: AppSettings = (appSettings ?? {}) as AppSettings;
  const themeId = safeSettings.workoutSettings?.selectedTheme || 'deepCosmos';

  useEffect(() => {
    try {
      const variables = getThemeVariables(themeId);
      const root = document.documentElement;
      Object.entries(variables).forEach(([key, value]) => root.style.setProperty(key, value));
      document.body.setAttribute('data-theme', themeId);
    } catch (err) {
      console.error('Failed to apply theme:', err);
    }
  }, [themeId]);

  useEffect(() => {
    try {
      localStorage.setItem('appSettings', JSON.stringify(safeSettings));
    } catch (err) {
      console.error('Failed to save app settings:', err);
    }
  }, [safeSettings]);
};

/**
 * Manage Screen Wake Lock based on settings
 */
const useWorkoutWakeLock = (keepAwake: boolean) => {
  const { request, release, isSupported } = useWakeLock();

  useEffect(() => {
    if (keepAwake && isSupported) {
      request();
    } else {
      release();
    }
    return () => {
      release();
    };
  }, [keepAwake, isSupported, request, release]);
};

const useWorkoutTimerLoop = (
  isPaused: boolean,
  isRestTimerActive: boolean,
  dispatch: Dispatch<WorkoutAction>
) => {
  useEffect(() => {
    let frameId: number;

    const tick = () => {
      dispatch({ type: 'SYNC_TIMER' });
      frameId = requestAnimationFrame(tick);
    };

    if (!isPaused || isRestTimerActive) {
      frameId = requestAnimationFrame(tick);
    }

    return () => {
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }, [isPaused, isRestTimerActive, dispatch]);
};

const useWorkoutConfetti = (showConfetti: boolean, dispatch: Dispatch<WorkoutAction>) => {
  useEffect(() => {
    if (!showConfetti) return;

    const timer = setTimeout(() => dispatch({ type: 'HIDE_CONFETTI' }), 2000);

    return () => clearTimeout(timer);
  }, [showConfetti, dispatch]);
};

const useWorkoutHaptics = (
  pendingHaptic: WorkoutState['pendingHaptic'],
  hapticsEnabled: boolean | undefined,
  dispatch: Dispatch<WorkoutAction>
) => {
  useEffect(() => {
    if (!pendingHaptic) return;

    if (hapticsEnabled) {
      const pattern =
        pendingHaptic === 'REST_END' ? HAPTIC_PATTERNS.REST_END : HAPTIC_PATTERNS.SET_COMPLETE;
      triggerHaptic(pattern);
    }

    dispatch({ type: 'CLEAR_PENDING_HAPTIC' });
  }, [pendingHaptic, hapticsEnabled, dispatch]);
};

const useWaterReminder = (
  enabled: boolean | undefined,
  intervalMinutes: number | undefined,
  isPaused: boolean,
  dispatch: Dispatch<WorkoutAction>
) => {
  useEffect(() => {
    if (!enabled) return;

    const intervalMs = (intervalMinutes || 15) * 60 * 1000;
    const timer = setInterval(() => {
      if (!isPaused) {
        dispatch({
          type: 'SET_MODAL_STATE',
          payload: { modal: 'water', isOpen: true },
        });
      }
    }, intervalMs);

    return () => clearInterval(timer);
  }, [enabled, intervalMinutes, isPaused, dispatch]);
};

const usePersistWorkoutState = (state: WorkoutState, saveState: (state: WorkoutState) => void) => {
  useEffect(() => {
    try {
      saveState(state);
    } catch (err) {
      console.error('Failed to save workout state:', err);
    }
  }, [state, saveState]);
};

const useWorkoutStateRef = (state: WorkoutState) => {
  const stateRef = useRef(state);

  useEffect(() => {
    stateRef.current = state;
  }, [state]);

  return stateRef;
};

const useWorkoutParentSync = (
  itemId: string,
  exercises: Exercise[],
  workoutDurationSeconds: number,
  onUpdateRef: MutableRefObject<(id: string, updates: Partial<PersonalItem>) => void>
) => {
  const lastUpdateRef = useRef({
    exercises,
    duration: workoutDurationSeconds,
  });

  useEffect(() => {
    const shouldUpdate =
      lastUpdateRef.current.exercises !== exercises ||
      Math.abs(lastUpdateRef.current.duration - workoutDurationSeconds) > 5;

    if (shouldUpdate) {
      lastUpdateRef.current = {
        exercises,
        duration: workoutDurationSeconds,
      };

      onUpdateRef.current(itemId, {
        exercises,
        workoutDuration: Math.floor(workoutDurationSeconds),
      });
    }
  }, [exercises, workoutDurationSeconds, itemId, onUpdateRef]);
};

export const useActiveWorkout = (
  item: PersonalItem,
  onUpdate: (id: string, updates: Partial<PersonalItem>) => void,
  onExit: () => void
) => {
  const { loadState, saveState, clearState } = useWorkoutPersistence<WorkoutState>({
    key: STORAGE_KEY, // New Key forces fresh start
    debounceMs: 1000,
    maxAge: 4 * 60 * 60 * 1000,
  });

  // 1. Initialize
  // Use lazy initialization so we only hit persistence/localStorage once
  const [state, dispatch] = useImmerReducer<WorkoutState, WorkoutAction>(
    workoutReducer,
    { item, loadState },
    ({ item, loadState }) => createInitialState(item, loadState)
  );

  // 2. Refs
  const stateRef = useWorkoutStateRef(state);

  // 3. Save
  usePersistWorkoutState(state, saveState);

  // 4. Ghost Values
  const currentExerciseName =
    Array.isArray(state?.exercises) &&
      typeof state.currentExerciseIndex === 'number' &&
      state.currentExerciseIndex >= 0 &&
      state.currentExerciseIndex < state.exercises.length
      ? state.exercises[state.currentExerciseIndex]?.name
      : undefined;

  usePreviousExerciseData(currentExerciseName, dispatch);

  // 5. PRs
  const { prMap, getPRForExercise } = useWorkoutPersonalRecords(state, dispatch);

  // 6. Theme & app settings
  useWorkoutThemeAndSettings(state.appSettings);

  // 7. Update Parent
  const onUpdateRef = useRef(onUpdate);
  const onExitRef = useRef(onExit);

  useEffect(() => {
    onUpdateRef.current = onUpdate;
    onExitRef.current = onExit;
  }, [onUpdate, onExit]);

  useWorkoutParentSync(item.id, state.exercises, state.workoutTimerDisplay, onUpdateRef);

  // 8. Timer Loop
  useWorkoutTimerLoop(state.isPaused, !!state.restTimer?.active, dispatch);

  // 9. Side Effects
  useWorkoutConfetti(state.showConfetti, dispatch);

  useWakeLock(!!state.appSettings?.workoutSettings?.keepAwake);

  useWorkoutHaptics(
    state.pendingHaptic,
    state.appSettings?.workoutSettings?.hapticsEnabled,
    dispatch
  );

  useWaterReminder(
    state.appSettings?.workoutSettings?.waterReminderEnabled,
    state.appSettings?.workoutSettings?.waterReminderInterval,
    state.isPaused,
    dispatch
  );

  // Derived workout stats for premium UI components
  const workoutStats = useMemo(() => {
    const exercises = state.exercises || [];
    let totalSets = 0;
    let completedSets = 0;
    let totalVolume = 0;

    for (const ex of exercises) {
      const sets = ex.sets || [];
      totalSets += sets.length;

      for (const set of sets) {
        if (set.completedAt) {
          completedSets += 1;
          if (set.weight && set.reps) {
            totalVolume += set.weight * set.reps;
          }
        }
      }
    }

    const progressPercent = totalSets > 0 ? (completedSets / totalSets) * 100 : 0;

    return {
      totalSets,
      completedSets,
      totalVolume,
      progressPercent,
    } as const;
  }, [state.exercises]);

  // 10. Finish
  const formatTime = useCallback((seconds: number) => {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);
    if (h > 0) return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
  }, []);

  const finishWorkout = useCallback(async (): Promise<WorkoutSession | undefined> => {
    const currentState = stateRef.current;

    const completedSets = currentState.exercises.reduce(
      (acc, ex) => acc + ex.sets.filter(s => s.completedAt).length,
      0
    );
    const finalDuration = Math.floor(currentState.workoutTimerDisplay);

    const sessionData: WorkoutSession = {
      id: `session-${Date.now()}`,
      workoutItemId: item.id,
      startTime: item.workoutStartTime || new Date(Date.now() - finalDuration * 1000).toISOString(),
      endTime: new Date().toISOString(),
      exercises: currentState.exercises,
      goalType: currentState.appSettings?.workoutSettings?.defaultWorkoutGoal,
    };

    onUpdateRef.current(item.id, {
      exercises: currentState.exercises,
      workoutDuration: finalDuration,
    });

    clearState();

    try {
      await saveWorkoutSession(sessionData);

      logEvent({
        eventType: 'workout_completed',
        itemId: item.id,
        itemTitle: item.title || 'אימון',
        metadata: {
          duration: finalDuration,
          exerciseCount: currentState.exercises.length,
          totalSets: completedSets,
        },
      });

      return sessionData;
    } catch (err) {
      console.error('Failed to finish workout:', err);
      throw err;
    }
  }, [item.id, item.title, item.workoutStartTime, clearState]);

  // --- Wake Lock Integration ---
  const keepAwake = state.appSettings?.workoutSettings?.keepAwake ?? false;
  useWorkoutWakeLock(keepAwake);

  return {
    state,
    dispatch,
    formatTime,
    finishWorkout,
    prMap,
    getPRForExercise,
    workoutStats,
  };
};
