// Workout Reducer - Sliced reducer pattern for better maintainability
import { WorkoutState, WorkoutAction } from './workoutTypes';
import { WorkoutSet } from '../../../types';

// ============================================================
// HELPER FUNCTIONS
// ============================================================

const createNextSet = (currentSet: WorkoutSet): WorkoutSet & { isAutoGenerated?: boolean } => ({
    reps: currentSet.reps,
    weight: currentSet.weight,
    notes: currentSet.notes,
    rpe: currentSet.rpe,
    restTime: currentSet.restTime,
    isAutoGenerated: true,
});

const getActiveSetIndex = (sets: WorkoutSet[]): number => {
    const idx = sets.findIndex(s => !s.completedAt);
    return idx === -1 ? sets.length : idx;
};

// ============================================================
// EXERCISE SLICE
// ============================================================

const exerciseReducer = (draft: WorkoutState, action: WorkoutAction): void => {
    switch (action.type) {
        case 'ADD_EXERCISE': {
            const exerciseName = action.payload?.name?.trim();
            if (!exerciseName) {
                console.warn('Blocked attempt to add exercise without name');
                return;
            }
            draft.exercises.push({ ...action.payload, name: exerciseName });
            draft.showExerciseSelector = false;
            draft.showQuickForm = false;
            break;
        }

        case 'REMOVE_EXERCISE': {
            draft.exercises.splice(action.payload, 1);
            if (draft.currentExerciseIndex >= draft.exercises.length) {
                draft.currentExerciseIndex = Math.max(0, draft.exercises.length - 1);
            }
            break;
        }

        case 'REORDER_EXERCISES': {
            draft.exercises = action.payload.filter(ex => ex.name?.trim());
            break;
        }

        case 'CHANGE_EXERCISE': {
            draft.currentExerciseIndex = action.payload;
            break;
        }

        case 'RENAME_EXERCISE': {
            const { index, name } = action.payload;
            const exercise = draft.exercises[index];
            if (exercise && name.trim()) {
                exercise.name = name.trim();
            }
            break;
        }

        case 'UPDATE_EXERCISE_META': {
            const { index, muscleGroup, tempo, targetRestTime, tutorialText } = action.payload;
            const exercise = draft.exercises[index];
            if (exercise) {
                if (muscleGroup !== undefined) exercise.muscleGroup = muscleGroup;
                if (tempo !== undefined) exercise.tempo = tempo;
                if (targetRestTime !== undefined) exercise.targetRestTime = targetRestTime;
                if (tutorialText !== undefined) exercise.tutorialText = tutorialText;
            }
            break;
        }

        case 'SET_EXERCISES': {
            draft.exercises = action.payload.filter(ex => ex.name?.trim());
            break;
        }
    }
};

// ============================================================
// SET SLICE
// ============================================================

const setReducer = (draft: WorkoutState, action: WorkoutAction): void => {
    const exercise = draft.exercises[draft.currentExerciseIndex];
    if (!exercise && action.type !== 'SET_EXERCISES') return;

    switch (action.type) {
        case 'UPDATE_SET': {
            if (!exercise) return;
            const activeIdx = getActiveSetIndex(exercise.sets);
            if (!exercise.sets[activeIdx]) {
                exercise.sets[activeIdx] = { reps: 0, weight: 0 };
            }

            const activeSet = exercise.sets[activeIdx];
            if (activeSet && 'isAutoGenerated' in activeSet) {
                delete (activeSet as { isAutoGenerated?: boolean }).isAutoGenerated;
            }

            exercise.sets[activeIdx][action.payload.field] = action.payload.value;
            break;
        }

        case 'COMPLETE_SET': {
            if (!exercise) return;
            const activeIdx = getActiveSetIndex(exercise.sets);
            if (!exercise.sets[activeIdx]) {
                exercise.sets[activeIdx] = { reps: 0, weight: 0 };
            }

            const currentSet = exercise.sets[activeIdx];
            if (!currentSet) return;

            currentSet.completedAt = new Date().toISOString();

            if ('isAutoGenerated' in currentSet) {
                delete (currentSet as { isAutoGenerated?: boolean }).isAutoGenerated;
            }

            // Auto-add next set
            if (activeIdx === exercise.sets.length - 1) {
                exercise.sets.push(createNextSet(currentSet));
            }

            // Start rest timer
            const restTime = exercise.targetRestTime ||
                draft.appSettings.workoutSettings?.defaultRestTime || 60;

            draft.restTimer = {
                active: true,
                endTime: Date.now() + restTime * 1000,
                totalTime: restTime,
                timeLeft: restTime,
            };

            // Haptic feedback
            if (draft.appSettings.workoutSettings?.hapticsEnabled) {
                draft.pendingHaptic = 'SET_COMPLETE';
            }

            // Confetti
            const intensity = draft.appSettings.animationIntensity;
            if (intensity === 'default' || intensity === 'full') {
                draft.showConfetti = true;
            }
            break;
        }

        case 'UNDO_LAST_SET': {
            if (!exercise) return;
            let lastCompletedIndex = -1;
            for (let i = exercise.sets.length - 1; i >= 0; i--) {
                if (exercise.sets[i]?.completedAt) {
                    lastCompletedIndex = i;
                    break;
                }
            }

            if (lastCompletedIndex !== -1) {
                const setToUndo = exercise.sets[lastCompletedIndex];
                if (setToUndo) {
                    delete setToUndo.completedAt;
                }

                const nextSet = exercise.sets[lastCompletedIndex + 1];
                if (nextSet && 'isAutoGenerated' in nextSet && nextSet.isAutoGenerated) {
                    exercise.sets.splice(lastCompletedIndex + 1, 1);
                }
            }
            break;
        }

        case 'UPDATE_SET_NOTES': {
            if (!exercise) return;
            const activeIdx = getActiveSetIndex(exercise.sets);
            if (activeIdx < 0 || !exercise.sets[activeIdx]) return;
            exercise.sets[activeIdx].notes = action.payload;
            break;
        }

        case 'UPDATE_SET_RPE': {
            if (!exercise) return;
            const activeIdx = getActiveSetIndex(exercise.sets);
            if (activeIdx < 0 || !exercise.sets[activeIdx]) return;
            exercise.sets[activeIdx].rpe = action.payload;
            break;
        }

        case 'COPY_PREVIOUS_SET': {
            if (!exercise) return;
            const activeIdx = getActiveSetIndex(exercise.sets);
            if (activeIdx <= 0) return;

            const previousSet = exercise.sets[activeIdx - 1];
            if (!previousSet) return;

            if (!exercise.sets[activeIdx]) {
                exercise.sets[activeIdx] = { reps: 0, weight: 0 };
            }

            exercise.sets[activeIdx].weight = previousSet.weight || 0;
            exercise.sets[activeIdx].reps = previousSet.reps || 0;
            break;
        }

        case 'DUPLICATE_SET': {
            if (!exercise) return;
            const activeIdx = getActiveSetIndex(exercise.sets);
            if (activeIdx < 0 || !exercise.sets[activeIdx]) return;

            const currentSet = exercise.sets[activeIdx];
            const newSet: WorkoutSet = {
                weight: currentSet.weight || 0,
                reps: currentSet.reps || 0,
                notes: currentSet.notes,
                rpe: currentSet.rpe,
                restTime: currentSet.restTime,
            };

            exercise.sets.splice(activeIdx + 1, 0, newSet);
            break;
        }
    }
};

// ============================================================
// TIMER SLICE
// ============================================================

const timerReducer = (draft: WorkoutState, action: WorkoutAction): void => {
    switch (action.type) {
        case 'TOGGLE_PAUSE': {
            draft.isPaused = !draft.isPaused;
            if (draft.isPaused) {
                draft.lastPauseTimestamp = Date.now();
            } else if (draft.lastPauseTimestamp) {
                draft.totalPausedTime += Date.now() - draft.lastPauseTimestamp;
                draft.lastPauseTimestamp = null;
            }
            break;
        }

        case 'SKIP_REST': {
            draft.restTimer.active = false;
            draft.restTimer.endTime = null;
            break;
        }

        case 'ADD_REST_TIME': {
            if (draft.restTimer.endTime) {
                draft.restTimer.endTime += action.payload * 1000;
            }
            break;
        }

        case 'SET_REST_TIME': {
            draft.restTimer = {
                active: true,
                endTime: Date.now() + action.payload * 1000,
                totalTime: action.payload,
                timeLeft: action.payload,
            };
            break;
        }

        case 'SYNC_REST_TIMER': {
            if (!draft.restTimer) {
                draft.restTimer = { active: false, endTime: null, totalTime: 0, timeLeft: 0 };
                return;
            }

            if (draft.restTimer.active && draft.restTimer.endTime) {
                const left = (draft.restTimer.endTime - Date.now()) / 1000;
                draft.restTimer.timeLeft = Math.max(0, left);

                if (left <= 0) {
                    draft.restTimer.active = false;
                    draft.restTimer.endTime = null;
                    if (draft.appSettings?.workoutSettings?.hapticsEnabled) {
                        draft.pendingHaptic = 'REST_END';
                    }
                }
            }
            break;
        }
    }
};

// ============================================================
// UI SLICE
// ============================================================

const uiReducer = (draft: WorkoutState, action: WorkoutAction): void => {
    switch (action.type) {
        case 'OPEN_NUMPAD':
            draft.numpad = { isOpen: true, target: action.payload, value: '' };
            break;

        case 'CLOSE_NUMPAD':
            draft.numpad.isOpen = false;
            break;

        case 'NUMPAD_INPUT':
            draft.numpad.value += action.payload;
            break;

        case 'NUMPAD_DELETE':
            draft.numpad.value = draft.numpad.value.slice(0, -1);
            break;

        case 'NUMPAD_SUBMIT': {
            if (draft.numpad.target) {
                let val = parseFloat(draft.numpad.value);
                if (!isNaN(val)) {
                    if (draft.numpad.target === 'reps') {
                        val = Math.max(0, Math.round(val || 0));
                    }

                    const exercise = draft.exercises[draft.currentExerciseIndex];
                    if (exercise) {
                        const activeIdx = getActiveSetIndex(exercise.sets);
                        if (!exercise.sets[activeIdx]) {
                            exercise.sets[activeIdx] = { reps: 0, weight: 0 };
                        }
                        exercise.sets[activeIdx][draft.numpad.target] = val;

                        const activeSet = exercise.sets[activeIdx];
                        if (activeSet && 'isAutoGenerated' in activeSet) {
                            delete (activeSet as { isAutoGenerated?: boolean }).isAutoGenerated;
                        }
                    }
                }
            }
            draft.numpad.isOpen = false;
            break;
        }

        case 'TOGGLE_DRAWER':
            draft.isDrawerOpen = action.payload;
            break;

        case 'TOGGLE_SETTINGS':
            draft.showSettings = action.payload;
            break;

        case 'OPEN_SELECTOR':
            draft.showExerciseSelector = true;
            break;

        case 'CLOSE_SELECTOR':
            draft.showExerciseSelector = false;
            break;

        case 'OPEN_QUICK_FORM':
            draft.showQuickForm = true;
            break;

        case 'CLOSE_QUICK_FORM':
            draft.showQuickForm = false;
            break;

        case 'OPEN_EXERCISE_LIBRARY':
            draft.showExerciseLibrary = true;
            break;

        case 'CLOSE_EXERCISE_LIBRARY':
            draft.showExerciseLibrary = false;
            break;

        case 'OPEN_AI_COACH':
            draft.showAICoach = true;
            break;

        case 'CLOSE_AI_COACH':
            draft.showAICoach = false;
            break;
    }
};

// ============================================================
// MODAL SLICE
// ============================================================

const modalReducer = (draft: WorkoutState, action: WorkoutAction): void => {
    switch (action.type) {
        case 'SET_MODAL_STATE':
            if (action.payload.modal === 'goal') draft.showGoalSelector = action.payload.isOpen;
            if (action.payload.modal === 'warmup') draft.showWarmup = action.payload.isOpen;
            if (action.payload.modal === 'cooldown') draft.showCooldown = action.payload.isOpen;
            if (action.payload.modal === 'water') draft.showWaterReminder = action.payload.isOpen;
            if (action.payload.modal === 'tutorial') draft.showTutorial = action.payload.isOpen;
            if (action.payload.modal === 'aicoach') draft.showAICoach = action.payload.isOpen;
            break;

        case 'SHOW_TUTORIAL':
            draft.tutorialExercise = action.payload;
            draft.showTutorial = true;
            break;

        case 'SHOW_PR_CELEBRATION':
            draft.showPRCelebration = action.payload;
            break;

        case 'HIDE_PR_CELEBRATION':
            draft.showPRCelebration = null;
            break;

        case 'HIDE_CONFETTI':
            draft.showConfetti = false;
            break;
    }
};

// ============================================================
// DATA SLICE
// ============================================================

const dataReducer = (draft: WorkoutState, action: WorkoutAction): void => {
    switch (action.type) {
        case 'UPDATE_SETTINGS':
            if (!draft.appSettings) {
                draft.appSettings = {} as typeof draft.appSettings;
            }
            draft.appSettings.workoutSettings = {
                ...(draft.appSettings.workoutSettings || {}),
                ...action.payload,
            };
            break;

        case 'SET_PREVIOUS_DATA':
            draft.previousExerciseData = action.payload;
            break;

        case 'CLEAR_PENDING_HAPTIC':
            draft.pendingHaptic = null;
            break;
    }
};

// ============================================================
// MAIN REDUCER (Combines all slices)
// ============================================================

export const workoutReducer = (draft: WorkoutState, action: WorkoutAction): void => {
    exerciseReducer(draft, action);
    setReducer(draft, action);
    timerReducer(draft, action);
    uiReducer(draft, action);
    modalReducer(draft, action);
    dataReducer(draft, action);
};

export default workoutReducer;
